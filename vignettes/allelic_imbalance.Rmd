---
title: "allelic_imbalance"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{allelic_imbalance}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
# Identifying genes with allelic imbalance

## Introduction

ASPEN is a suite of statistical tests for evaluating allele-specific expression (ASE). It models the allelic ratio — defined as the fraction of reads from the reference allele relative to the total number of reads mapped to a gene — using the beta-binomial distribution. The allelic ratio is restricted to $[0,1]$ interval and its distribution can be described with beta-binomial mean, $\mu$, and dispersion, $\theta$.

As with other sequencing-based measurements, single-cell RNA-seq counts exhibit mean–variance bias: lowly expressed genes tend to display higher relative variability than highly expressed genes. ASPEN mitigates this bias by modelling allelic dispersion, $\theta$, as a function of gene expression. Useing the hierarchical Bayes approach, it shrinks the original dispersion estimates toward the common trend, which represents the level of dispersion expected for genes with similar expression.

ASPEN requires two input matrices: the reference allele counts and the total counts (a sum of counts from both alleles). 

The main steps in the workflow are as follows:
\begin{enumerate}
\item 1) estimate beta-binomial distribution parameters. For each gene, the beta-binomial parameters  $\alpha$ and $\beta$ are estimated by maximum likelihood estimation (MLE). Using $\alpha$ and $\beta$, we can calculate allelic ratio mean, $\mu$, and dispersion, $\theta$ as
\\ $\mu=\frac{\alpha}{\alpha + \beta}$, and
\\ $\theta = \frac{1}{\alpha + \beta}$;
\item 2) fit a local regression for $\theta$ as a function of total gene expression;
\item 3) estimate shrinkage parameters, $\delta$ and $N$, appropriate for your data;
\item 4) shrink the original $\theta$ towards the common trend;
\item 5) perform the LRT test to detect genes with allelic imbalance.
\end{enumerate}

## Setup
```{r setup}
#loading required libraries
suppressPackageStartupMessages({
  library(ASPEN)
  library(gridExtra)
  library(openxlsx)
  library(knitr)
  library(SingleCellExperiment)
  library(scran)
  library(huxtable)
})
```

## Loading allele-specifc count data
In this example, we use mouse brain organoid data from Bl6Cast F1 hybrids (Medina-Cano et al., 2025). We load the reference allele counts (Bl6 counts) and the total counts (sum of counts from both alleles). Cell identities were previously annotated based on marker gene expression, resulting in five major cell types: neurogenic progenitor cells (adial glial cells, RGCs), intermediate progenitors cells (IPCs), deep layer neurons (cortical neurons), gliogenic progenitor cells (gliogenic RGCs) and olygodendrocyte precursor cells (OPCs).
```{r}
data("Bl6_Cast_a1")
data("Bl6_Cast_tot")
load_file <- system.file("extdata", "Bl6_Cast_cell_annot.xlsx", package = "ASPEN")
cell_annot <- read.xlsx(load_file, rowNames = T)
#adding barcode id
cell_annot$cell_id <- paste(cell_annot$clone, cell_annot$cell_barcode, sep = "_")
print_md(as_huxtable(head(cell_annot)))
```


The cell abundance for each neuronal subtype
```{r}
print_md(as_huxtable(table(cell_annot$cell_idents)))
```

## Counts normalisation
We first normalize the raw single-cell counts using the [`computeSumFactors()`] function from `scran` package (Lun, et al. 2016). We then create a `SingleCellExperiment` object using the total and reference allele count matrices.

```{r}
#keeping annotated cells in the count matrices
Cast_B6_a1 <- Cast_B6_a1[,gsub(".*_", "", colnames(Cast_B6_a1)) %in% cell_annot$cell_barcode]
Cast_B6_tot <- Cast_B6_tot[,gsub(".*_", "", colnames(Cast_B6_tot)) %in% cell_annot$cell_barcode]

#creating SingleCellExperiment object
ase_sce <- SingleCellExperiment(assays = list(a1 = as.matrix(Cast_B6_a1),
                                              tot = as.matrix(Cast_B6_tot)))

```


Lowly expressed genes (expressed in less than 10 cells) are removed.
```{r}
#removing lowly expressed genes
ase_sce <- ase_sce[rowSums(assays(ase_sce)[['tot']] > 1) >= 10, ]
print_md(as_huxtable(dim(ase_sce)))

```


```{r}
#adding sample id to the metadata
colData(ase_sce)$replicate <- gsub("_.*", "", rownames(colData(ase_sce)))

#calculate size factors
ase_sce <- computeSumFactors(ase_sce, 
                             clusters=colData(ase_sce)$replicate, assay.type = "tot")
```

The reference allele and total counts are normalized in parallel using the same size factor estimates.
```{r}
#normalizing counts
ase_sce  <- logNormCounts(ase_sce, 
                          size.factors = colData(ase_sce)$sizeFactor,
                          log = NULL, transform = "none", assay.type = "tot", name = "tot_norm")

#normalizing reference counts by the same size factors
ase_sce  <- logNormCounts(ase_sce, 
                          size.factors = colData(ase_sce)$sizeFactor,
                          log = NULL, transform = "none", assay.type = "a1", name = "a1_norm")

#checking that normalised counts assays are added to the SingleCellExperiment object
ase_sce@assays
```



## Splitting count matrices by cell type
Allelic imbalance test is run separately for each cell type. First, we split the metadata object by cell types. 
```{r}
#splitting the metadata by cell type
cell_list <- split(cell_annot, f = cell_annot$cell_idents)
```


Since beta-binomial parameters are estimated from raw counts, we first split the raw total and reference allele count matrices by cell type.
```{r}
#splitting SingleCellExperiemnt object by cell types
ase_sce_byct <- list()
for (i in 1:length(cell_list)){
    ase_sce_byct[[i]] <- ase_sce[,colnames(ase_sce) %in% cell_list[[i]]$cell_id]
}

#removing genes with low expression
ase_sce_byct_filt <- lapply(ase_sce_byct, function(q) 
                                          q[rowSums(assays(q)[['tot']] > 1) >= 10, ]) 

#extracting raw total counts
tot_mat <- lapply(ase_sce_byct_filt, function(q) as.matrix(assays(q)[['tot']]))
#extracting raw reference allele counts
a1_mat <- lapply(ase_sce_byct_filt, function(q) as.matrix(assays(q)[['a1']]))
#selecting genes that matched filtering criteria
a1_mat <- mapply(function(p,q) p[rownames(q), ], a1_mat, tot_mat, SIMPLIFY = F)

```


Before proceeding, we check that the reference and total count matrices have the same dimensions. This is for demonstration purposes only. If this condition is not met, ASPEN will issue a warning.
```{r}
mapply(function(p, q) dim(p) == dim(q), a1_mat, tot_mat, SIMPLIFY = F)
```

Next, we check that the gene order is identical between the reference and total count matrices. Again, this is for demonstration purposes only. If this condition is not met, ASPEN will issue a warning.
```{r}
mapply(function(p, q) table(rownames(p) == rownames(q)), a1_mat, tot_mat, SIMPLIFY = F)
```


## Estimating beta-binomial parameters
We estimate beta-binomial parameters separately for each cell type. 
```{r}
bb_init_params <- mapply(function(p, q) estim_bbparams(p, q, min_cells = 5, cores = 6), a1_mat, tot_mat, SIMPLIFY = F)
```


The output is a table with the following columns:
\begin{itemize}
  \item \textbf{N} - number cell in which the minimum read coverage threshold was met;
  \item \textbf{AR} - estimated allelic ratio;
  \item \textbf{tot_gene_mean} - mean gene expression across all cells;
  \item \textbf{tot_gene_variance} - gene variance across all cells;
  \item \textbf{alpha} - beta-binomial alpha parameter;
  \item \textbf{beta} - beta-binomial beta parameter;
  \item \textbf{bb_mu} - beta-binomial mu, calculated as  $\mu=\frac{\alpha}{\alpha + \beta}$;
  \item \textbf{bb_theta} - beta-binomial theta, calculated as  $\theta = \frac{1}{\alpha + \beta}$.
\end{itemize}
```{r}
print_md(as_huxtable(head(bb_init_params[[1]])))
```


## Defining lowly expressed genes
ASPEN applies shrinkage selectively - genes with very low dispersion are not moderated and their allelic imbalance is evaluated using the unadjusted values. Genes with stable dispersion are determined based on the residuals from the dispersion modeling step. ASPEN calculates the meadian absolute deviation-squared (${MAD}^2$), which is used as a cut-off.
```{r}
min_cutoff <- lapply(bb_init_params, calc_mad)
min_cutoff
```


## Estimate appropriate shrinkage parameters
We estimate shrinkage parameters, $N$ and $\delta$, separately for each cell type. Optionally, genes with very low dispersion can be excluded from the estimation by setting a minimum cut-off value with `thetaFilter` parameter
```{r, warning=FALSE, message=F}
set.seed(1001011)
shrink_pars <- mapply(function(p, q) estim_delta(p, thetaFilter = q),
                      bb_init_params, min_cutoff, SIMPLIFY = F)
shrink_pars
```


## Performing Bayesian shrinkage
We use [`correct_theta()`] from `ASPEN` to obtain posterior dispersion estimates.  The minimum dispersion value is set with `thetaFilter` parameter.  and genes with residuals below that value are excluded shrinkage. 
```{r}
bb_init_params <- lapply(bb_init_params, function(q) q[!is.na(q$bb_theta),])
shrunk_estims_vardelta <- mapply(function(p, q) correct_theta(p, N_set = q[1], delta_set = q[2], thetaFilter = 0.001),
                                 bb_init_params, shrink_pars, SIMPLIFY = F)
print_md(as_huxtable(head(shrunk_estims_vardelta[[1]])))

```


## Visualizing model fit. 
Genes with extremely low dispersion levels form a distinct cluster in the dispersion–expression plot. We estimate that those genes have $\theta < 0.001$. To exclude them from the shrinkage procedure, we set `thetaFilter = 0.001` in the [`correct_theta()`] function.
```{r, fig.width=10, fig.height=6.5}
celltypes <- list("Cortical neurons", "Gliogenic RGCs", "IPCs", "OPCs", "RGCs")
p_disp <- mapply(function(p,q) plot_disp_fit_theta(p, midpoint = 100) +
                                          labs(subtitle = paste0(q, " Cast_B6")) + geom_hline(yintercept = log(1e-03), linetype = "dashed", linewidth = 1),
                 shrunk_estims_vardelta, celltypes, SIMPLIFY = F)
do.call(grid.arrange, c(p_disp, ncol = 3))
```


Visualizing original and shrunk $\theta$'s.

```{r, fig.width=10, fig.height=7.5}

p_disp <- mapply(function(p,q) plot_disp(p) +
                               labs(subtitle = paste0(q, " Cast_B6")) + 
                               geom_hline(yintercept = log(1e-03), linetype = "dashed", linewidth = 1),
                 shrunk_estims_vardelta, celltypes, SIMPLIFY = F)
do.call(grid.arrange, c(p_disp, ncol = 3))
```


Alternatively, we can set $\delta$ and $N$ parameters manually.
```{r}
shrunk_estims <- lapply(bb_init_params, function(q) correct_theta(q, delta_set = 50, N_set = 30, thetaFilter = 0.001))

```


```{r, fig.width=10, fig.height=7.5}
p_disp <- mapply(function(p,q) plot_disp(p) +
                               labs(subtitle = paste0(q, " Cast_B6")) + 
                               geom_hline(yintercept = log(1e-03), linetype = "dashed", linewidth = 1),
                 shrunk_estims, celltypes, SIMPLIFY = F)

do.call(grid.arrange, c(p_disp, ncol = 3))
```
### Estimating global beta-binomial parameters

Evaluating global beta-binomial parameters provides an overall measure of bias toward the reference allele. This is done by estimating beta-binomial distribution parameters across all genes, excluding those located on sex chromosomes and known imprinted genes. For the GRCm38 (mm10) mouse genome, the package includes predefined lists of X- and Y-linked genes as well as a set of validated imprinted genes. These can be excluded by passing them to the `genes.excl` parameter in the [`glob_disp()`] function.  
```{r}
load_file <- system.file("extdata", "mm10_genesXY.txt", package = "ASPEN")
genesXY <- read.table(load_file)
load_file <- system.file("extdata", "mm10_imprinted_genes.xlsx", package = "ASPEN")
genesIMPR <- read.xlsx(load_file, colNames = T)
genes2remove <- c(genesXY$V1, genesIMPR$imprinted.genes)

global_estims <- mapply(function(p, q)  glob_disp(p, q, genes.excl = genes2remove, min_counts = 5),
                        a1_mat, tot_mat, SIMPLIFY = F)
global_estims
```

## Visualizing global allelic ratio distribution across all genes. 
Deviation from the balanced allelic expression ($AR = 0.5$) indicates a presence of a skew towards the reference allele. If reference allele bias is detected, the null hypothesis for the allelic imbalance testing should be adjusted accordingly. For analysis of the Bl6Cast hybrids, instead of using $H_0: \mu = 0.5$, the null hypotheses will be adjusted to $H_0: \mu = 0.54$ for Cortical neurons and IPCs datasets and to $H_0: \mu = 0.53$ for Gliogenic RGCs, OPCs and RGCs.

```{r, fig.width=8, fig.height=5.5}
p_glob <- mapply(function(p,q,r,s) plot_glob_params(p, q, r, min_counts = 5) +
                               labs(subtitle = paste0(s, " Cast_B6")),
                 a1_mat, tot_mat, global_estims, celltypes, SIMPLIFY = F)
do.call(grid.arrange, c(p_glob, ncol = 3))
```

## Allelic imbalance test 
The allelic imbalance test is performed on the normalized counts.
```{r}
#extracting normalised reference allele and total counts
tot_norm <- lapply(ase_sce_byct_filt, function(q) as.matrix(assays(q)[['tot_norm']]))

#extracting raw reference allele counts
a1_norm <- lapply(ase_sce_byct_filt, function(q) as.matrix(assays(q)[['a1_norm']]))
#ensure that the genes order is the same
a1_norm <- mapply(function(p,q) p[rownames(q), ], a1_norm, tot_norm, SIMPLIFY = F)

```


We run [`bb_mean()`] to identify genes with allelic ratio deviating from the null hypothesis. By default, ASPEN requires each gene to be expressed in at least 5 cells with a minimum of 5 counts per cell. These thresholds can be adjusted with `min_cells` and `min_counts` parameters.
```{r, warning=F, message=F}
bb_mean_res <- mapply(function(p, q, r, s) bb_mean(p, q, r, 
                                                   min_cells = 5, min_counts = 5, 
                                                   glob_params = s), 
                      a1_norm, tot_norm, shrunk_estims, global_estims, SIMPLIFY = F)
```


The output of [`beta_binom_test()`] function is a table that combines the output of the [`estim_bbparams()`] and [`correct_theta()`] functions and adds the following columns:\\
\begin{itemize}
  \item \textbf{log2FC} - log2 fold change between the allelic counts;
  \item \textbf{loglik0_mean} - log likelihood value under the $H_0$ for the allelic imbalance test;
  \item \textbf{loglik1_mean} - log likelihood value under the $H_1$ for the allelic imbalance test;
  \item \textbf{llr_mean} - log likelihood ratio test statistic for the allelic imbalance test;
  \item \textbf{pval_mean} - p-value obtained from the $\chi^2$ test.
\end{itemize}
\\

If a gene does not meet the quality filter (here, a minimum of 5 cells with at least 5 mapped reads), the allelic imbalance test is not performed for that gene. These genes will have `NA` in the above fields. We remove such genes before calculating the false discovery rate (FDR).
```{r}
bb_mean_res <- lapply(bb_mean_res, function(q) q <- q[!is.na(q$pval_mean),])

#calculating fdr
bb_mean_res <- lapply(bb_mean_res, function(q) {q$fdr_mean <- p.adjust(q$pval_mean, 
                                                                       method = "fdr");                                                          q <- q[order(q$fdr_mean),];
                                                return(q)})

```

Top 10 genes with significant allelic imbalance after FDR-adjustment 
```{r}
lapply(bb_mean_res, function(q) q[1:10, c("AR", "fdr_mean")])
```

We can visualize the allelic distribution for some of the top-ranked genes.
In the plots below, each point represents a single cell, and points are colored by the log(mean expression).

```{r, fig.width=7.5, fig.height=4}
#specifiying genes for plotting
genes_select <- list("Stmn1", "Ftl1", "Mif")

#generating data frame for plotting
plot_data <- lapply(genes_select, function(q) makedf(a1_mat[[1]], tot_mat[[1]], gene = q))

p_ar_dist <- mapply(function(p,q,r) plot_distr(p, gene = q),
                 plot_data, genes_select, SIMPLIFY = F)
do.call(grid.arrange, c(p_ar_dist, ncol = 3))
```



